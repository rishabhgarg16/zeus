# -*- coding: utf-8 -*-
"""match_schedule_cron.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QU6ixPFA-AhK7MshJLH2Tn_fQI0ZUBZr
"""

# !pip install mysql-connector-python
import json
import time
import sys
import mysql.connector
import requests
from datetime import datetime

API_KEY="431a99b014msh80043dee4127356p13ecf1jsndcde82d54a11"

url = "https://cricbuzz-cricket.p.rapidapi.com/schedule/v1/international"

headers = {
    "x-rapidapi-host": "cricbuzz-cricket.p.rapidapi.com",
    "x-rapidapi-key": API_KEY
}

# Database connections
mydb = mysql.connector.connect(
    host="ls-a6927155ebc8223b62e0da94714b39337fdb981a.c9yg6ks8shtr.ap-south-1.rds.amazonaws.com",
    user="admin",
    password="adminpass",
    database="hit11"
)
mycursor = mydb.cursor()

def check_if_match_exists(external_match_id):
    query = "select * from matches where cricbuzz_match_id = %s"
    values = (external_match_id,)
    mycursor.execute(query, values)
    result = mycursor.fetchone()
    if result:
        return True

check_if_match_exists(101541)

def update_table(match_row):
    if not check_if_match_exists(match_row['cricbuzz_match_id']):
        print(f"Inserting row {match_row}")
        columns = ', '.join(match_row.keys())
        placeholders = ', '.join(['%s'] * len(match_row))
        query = "INSERT INTO matches ({}) VALUES ({})".format(columns, placeholders)
        values = tuple(match_row.values())

        try:
            mycursor.execute(query, values)
            mydb.commit()
            print(mycursor.rowcount, "record inserted.")
        except Exception as e:
            print(f"Error updating {match_row['cricbuzz_match_id']} due to {e}")
    else:
        print(f"Match already exist with externalid {match_row['cricbuzz_match_id']}")

def get_or_create_internal_team_id(external_id, team_name, team_short_name):
    cursor = mycursor

    # Try to get existing team
    query = "SELECT id as internal_id FROM teams WHERE cricbuzz_team_id = %s"
    cursor.execute(query, (external_id,))
    result = cursor.fetchone()

    if result:
        internal_id = result[0]
    else:
        # Team not found, create new entry in Zeus
        new_team = {
            'cricbuzz_team_id': external_id,
            'team_name': team_name,
            'team_short_name': team_short_name,
            'team_image_url': None,  # We don't have this info from Cricbuzz
            'created_at': datetime.now(),
            'updated_at': datetime.now()
        }

        # Insert new team into Zeus
        insert_query = """
        INSERT INTO teams (team_name, team_short_name, team_image_url, cricbuzz_team_id, created_at, updated_at)
        VALUES (%(team_name)s, %(team_short_name)s, %(team_image_url)s, %(cricbuzz_team_id)s, %(created_at)s, %(updated_at)s)
        """
        # print(new_team)
        cursor.execute(insert_query, new_team)
        internal_id = cursor.lastrowid

        mydb.commit()
        print(f"Created new team: {team_name} with internal ID: {internal_id}")

    # cursor.close()
    return internal_id

def call_schedule_api():
    response = requests.request("GET", url, headers=headers)

    match_data = response.json()
    for matchList in match_data['matchScheduleMap']:
        if 'scheduleAdWrapper' in matchList:
            for match in matchList['scheduleAdWrapper']['matchScheduleList']:
                for matchInfo in match['matchInfo']:
                    team1_id = get_or_create_internal_team_id(matchInfo['team1']['teamId'], matchInfo['team1']['teamName'], matchInfo['team1']['teamSName'])
                    team2_id = get_or_create_internal_team_id(matchInfo['team2']['teamId'], matchInfo['team2']['teamName'], matchInfo['team2']['teamSName'])
                    match_row = {
                        'cricbuzz_match_id': matchInfo['matchId'],
                        'team1': matchInfo['team1']['teamName'],
                        'team2': matchInfo['team2']['teamName'],
                        'stadium': matchInfo['venueInfo']['ground'],
                        'city': matchInfo['venueInfo']['city'],
                        'country': matchInfo['venueInfo']['country'],
                        'match_type': match['seriesCategory'],
                        'match_format': matchInfo['matchFormat'],
                        'start_date': datetime.fromtimestamp(int(int(matchInfo['startDate'])/1000)),
                        'end_date': datetime.fromtimestamp(int(int(matchInfo['endDate'])/1000)),
                        'status': "Scheduled",
                        'tournament_name': match['seriesName'],
                        'created_at': datetime.now(),
                        'updated_at': datetime.now(),
                        'team1_id': team1_id,
                        'team2_id': team2_id
                    }
                    update_table(match_row)


call_schedule_api()
sys.stdout.flush()
time.sleep(21600) # 6 hours